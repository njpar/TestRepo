################################################################################
##   ____  ____
##  /   /\/   /
## /___/  \  /    Vendor: Xilinx
## \   \   \/     Version : 3.0
##  \   \         Application : XAPP589, All digital VCXO.
##  /   /         Filename : pre_opt.tcl
## /___/   /\     Timestamp : v26_EA_0 @ Thu Mar 23 18:36:33 +0000 2017 Rev: 847:857
## \   \  /  \ 
##  \___\/\___\
##
##
## USER CONSTRAINTS FILE FOR MGT WRAPPER EXAMPLE DESIGN
## Generated by Xilinx 7 Series FPGAs Transceivers Wizard
##
## Device:  xc7k325t
## Package: ffg900
##
## (c) Copyright 2010-2014 Xilinx, Inc. All rights reserved.
##
## This file contains confidential and proprietary information
## of Xilinx, Inc. and is protected under U.S. and
## international copyright and other intellectual property
## laws.
##
## DISCLAIMER
## This disclaimer is not a license and does not grant any
## rights to the materials distributed herewith. Except as
## otherwise provided in a valid license issued to you by
## Xilinx, and to the maximum extent permitted by applicable
## law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
## WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
## AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
## BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
## INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
## (2) Xilinx shall not be liable (whether in contract or tort,
## including negligence, or under any other theory of
## liability) for any loss or damage of any kind or nature
## related to, arising under or in connection with these
## materials, including for any direct, or any indirect,
## special, incidental, or consequential loss or damage
## (including loss of data, profits, goodwill, or any type of
## loss or damage suffered as a result of any action brought
## by a third party) even if such damage or loss was
## reasonably foreseeable or Xilinx had been advised of the
## possibility of the same.
##
## CRITICAL APPLICATIONS
## Xilinx products are not designed or intended to be fail-
## safe, or for use in any application requiring fail-safe
## performance, such as life-support or safety devices or
## systems, Class III medical devices, nuclear facilities,
## applications related to the deployment of airbags, or any
## other applications that could lead to death, personal
## injury, or severe property or environmental damage
## (individually and collectively, "Critical
## Applications"). Customer assumes the sole risk and
## liability of any use of Xilinx products in Critical
## Applications, subject only to applicable laws and
## regulations governing limitations on product liability.
## 
## THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
## PART OF THIS FILE AT ALL TIMES. 

proc hex2bin {hex} {
  binary scan [binary format H1 $hex] B4 bin
  return $bin
};

proc bin2hex {bin} {
  binary scan [binary format B8 [string range $bin 3 end]] H2 hex
  return $hex
};

proc get_rpm_elements {start} {
    set i 0;
    set pin_O [get_pins -leaf -of $start -filter {DIRECTION == OUT}];
    set pin_C {};
    while {[llength $pin_C] == 0 && $i != 50} {
        set net [get_nets -quiet -of $pin_O];
        set pin_I [get_pins -leaf -quiet -of $net -filter {DIRECTION == IN && NAME =~ "*I0"}];
        set pin_C [get_pins -leaf -quiet -of $net -filter {DIRECTION == IN && NAME =~ "*C"}];
        set pin_D [get_pins -leaf -quiet -of $net -filter {DIRECTION == IN && NAME =~ *D}];
        set cell [get_cells -quiet -of $pin_I];
        set FF [get_cells -quiet -of $pin_D];
        set pin_O [get_pins -leaf -quiet -of $cell -filter {DIRECTION == OUT}];
        lappend list_pin_I $pin_I;
        lappend list_cell $cell;
        lappend list_net $net;
        lappend list_FF $FF;
        incr i;
    };
    return [list "$list_net" "$list_cell" "$list_FF"];
};

proc picxo_drc {gts picxo mode} {
        set gt_sites [get_sites -quiet -of $gts];
        if {$gt_sites == ""} {
        send_msg_id {PICXO-102} {ERROR} "GT LOC not found for $picxo";
        } elseif {$mode == "PICXO"} {
            send_msg_id {PICXO-103} {INFO} "Running DRC for PICXO related to GT site $gt_sites";
            if {[get_property REF_NAME $gts] == "GTXE2_CHANNEL"} {
                set pcs_rsvd [lindex [split [get_property PCS_RSVD_ATTR [get_cells $gts]] {}] end];
                if {[lindex [split [hex2bin $pcs_rsvd] {}] end-1] == 1} {
                    send_msg_id {PICXO-016} {INFO} "$gts/PCS_RSVD_ATTR[1] is set to 1";
                } else {
                    send_msg_id {PICXO-017} {CRITICAL WARNING} "$gts/PCS_RSVD_ATTR[1] is set to 0";
                };
                set txdly [lindex [split [get_property TXDLY_LCFG [get_cells $gts]] {}] end];
                if {[lindex [split [hex2bin $txdly] {}] end-2] == 1} {
                    send_msg_id {PICXO-018} {INFO} "$gts/TXDLY_LCFG[2] is correctly set to 1";
                } else {
                    send_msg_id {PICXO-019} {CRITICAL WARNING} "$gts/TXDLY_LCFG[2] is set to 0";
                };
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXPHDLYPD]]] "Ground"] == 0 } {
                    send_msg_id {PICXO-001} {CRITICAL WARNING} "$gts/TXPHDLYPD must be connected to Ground";
                } else {
                    send_msg_id {PICXO-002} {INFO} "$gts/TXPHDLYPD is correctly connected to Ground";
                };
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXPHALIGN]]] "Power"] == 0 } {
                    send_msg_id {PICXO-003} {CRITICAL WARNING} "$gts/TXPHALIGN must be connected to VCC";
                } else {
                    send_msg_id {PICXO-004} {INFO} "$gts/TXPHALIGN is correctly connected to VCC";
                };
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXPHALIGNEN]]] "Power"] == 0 } {
                    send_msg_id {PICXO-005} {CRITICAL WARNING} "$gts/TXPHALIGNEN must be connected to VCC";
                    } else {
                    send_msg_id {PICXO-006} {INFO} "$gts/TXPHALIGNEN is correctly connected to VCC";
                };
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXPHOVRDEN]]] "Power"] == 0 } {
                    send_msg_id {PICXO-007} {CRITICAL WARNING} "$gts/TXPHOVRDEN must be connected to VCC";
                    } else {
                    send_msg_id {PICXO-008} {INFO} "$gts/TXPHOVRDEN is correctly connected to VCC";
                }
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXOUTCLKSEL[0]]]] "Ground"] == 0 } {
                    send_msg_id {PICXO-009} {CRITICAL WARNING} "$gts/TXOUTCLKSEL[0] must be connected to Ground";
                    } else {
                    send_msg_id {PICXO-010} {INFO} "$gts/TXOUTCLKSEL[0] is correctly connected to Ground";
                }
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXOUTCLKSEL[1]]]] "Power"] == 0 } {
                    send_msg_id {PICXO-011} {CRITICAL WARNING} "$gts/TXOUTCLKSEL[1] must be connected to VCC";
                    } else {
                    send_msg_id {PICXO-012} {INFO} "$gts/TXOUTCLKSEL[1] is correctly connected to VCC";
                }
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXOUTCLKSEL[2]]]] "Ground"] == 0 } {
                    send_msg_id {PICXO-013} {CRITICAL WARNING} "$gts/TXOUTCLKSEL[2] must be connected to Ground";
                    } else {
                    send_msg_id {PICXO-014} {INFO} "$gts/TXOUTCLKSEL[2] is correctly connected to Ground";
                };
                if {[get_pins -leaf -of [get_nets -segments -top -of [get_pins -of [get_cells $picxo] -filter {NAME =~ *TXOUTCLK_I || NAME =~ *txoutclk_i}]] -filter {direction == OUT}] == [get_pins -leaf -of [get_nets -top -segments -of [get_pins -of [get_cells $gts] -filter {NAME =~ *DRPCLK}]] -filter {direction == OUT}]} {
                     send_msg_id {PICXO-024} {INFO} "PICXO clock TXOUTCLK_I and GT TXUSRCLK2 have the same driver";
                } else {
                    send_msg_id {PICXO-024} {CRITICAL WARNING} "PICXO $picxo clock TXOUTCLK_I and GT $gts TXUSRCLK2 do not have the same driver, please check that these clocks are synchronous";
                };
            };
            if {[get_property REF_NAME $gts] == "GTPE2_CHANNEL" || [get_property REF_NAME $gts] == "GTHE2_CHANNEL" ||\
                [get_property REF_NAME $gts] == "GTHE3_CHANNEL" || [get_property REF_NAME $gts] == "GTYE3_CHANNEL" ||\
                [get_property REF_NAME $gts] == "GTHE4_CHANNEL" || [get_property REF_NAME $gts] == "GTYE4_CHANNEL" } {
                set txoutclksel [join "[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXOUTCLKSEL[2]]]] "Power"] \
                                       [string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXOUTCLKSEL[1]]]] "Power"] \
                                       [string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXOUTCLKSEL[0]]]] "Power"]" ""];
                set txprogsel [get_property TX_PROGCLK_SEL $gts];
                                     
                if {$txoutclksel == "010" || $txoutclksel == "001"} {
                    send_msg_id {PICXO-010} {INFO} "$gts/TXOUTCLKSEL is correctly set to $txoutclksel";
                } else {
                    ## vve this warning is generated even if we have GTHE3
                    if {[get_property REF_NAME $gts] != "GTHE3_CHANNEL" || [get_property REF_NAME $gts] != "GTYE3_CHANNEL"} {
                        send_msg_id {PICXO-011} {CRITICAL WARNING} "$gts/TXOUTCLKSEL must be set to 010 or 001";
                    } else {
                        if {$txoutclksel == "101" && $txprogsel = "POSTPI"} {
                            send_msg_id {PICXO-010} {INFO} "$gts/TXOUTCLKSEL is correctly set to 101 and $gts/TX_PROGCLK_SEL to 00 (POSTPI)";
                        } else {
                            ## vve to make this warning clearer, split conditions
                            send_msg_id {PICXO-010} {CRITICAL WARNING} "$gts/TXOUTCLKSEL must be set to 010, 001 or 101 when $gts/TX_PROGCLK_SEL to 00";
                        };
                    };
                };
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXPIPPMEN]]] "Power"] == 0 } {
                    send_msg_id {PICXO-003} {CRITICAL WARNING} "$gts/TXPIPPMEN must be connected to VCC"
                } else {
                    send_msg_id {PICXO-004} {INFO} "$gts/TXPIPPMEN is correctly connected to VCC"
                };
                if {[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/TXPIPPMSEL]]] "Power"] == 0 } {
                    send_msg_id {PICXO-005} {CRITICAL WARNING} "$gts/TXPIPPMSEL must be connected to VCC"
                } else {
                    send_msg_id {PICXO-006} {INFO} "$gts/TXPIPPMSEL is correctly connected to VCC"
                } 
                if {[get_clocks -of [get_pins $gts/TXUSRCLK2]] != [get_clocks -of [get_pins -filter {IS_CLOCK == 1} -of [get_cells -filter {IS_SEQUENTIAL == 1} -of [get_pins -leaf -filter {DIRECTION == OUT} -of [get_nets -of [get_pins $gts/TXPIPPMSTEPSIZE]]]]]] } {
                    send_msg_id {PICXO-007} {CRITICAL WARNING} "$gts/TXPIPPMSTEPSIZE is not synchronous to TXUSRCLK2"
                }
                set txpi_synfreq_ppm [split [get_property TXPI_SYNFREQ_PPM [get_cells $gts]] {}]
                if {[lindex $txpi_synfreq_ppm end] == 1} {
                    send_msg_id {PICXO-016} {INFO} "$gts/TXPI_SYNFREQ_PPM[0] is correctly set to 1"
                } else {
                    send_msg_id {PICXO-017} {CRITICAL WARNING} "$gts/TXPI_SYNFREQ_PPM[0] is set to 0, it must be set to 1"
                }
                if {[lindex $txpi_synfreq_ppm end-1] == 0} {
                    send_msg_id {PICXO-016} {INFO} "$gts/TXPI_SYNFREQ_PPM[1] is correctly set to 0"
                } else {
                    send_msg_id {PICXO-017} {CRITICAL WARNING} "$gts/TXPI_SYNFREQ_PPM[1] is set to 1, it must be set to 0"
                };
                if {[lindex $txpi_synfreq_ppm end-2] == 0} {
                    send_msg_id {PICXO-016} {INFO} "$gts/TXPI_SYNFREQ_PPM[2] is correctly set to 0"
                } else {
                    send_msg_id {PICXO-017} {CRITICAL WARNING} "$gts/TXPI_SYNFREQ_PPM[2] is set to 1, it must be set to 0"
                };
                if {[get_pins -leaf -of [get_nets -segments -top -of [get_pins -of [get_cells $picxo] -filter {NAME =~ *TXOUTCLK_I || NAME =~ *txoutclk_i}]] -filter {direction == OUT}] == [get_pins -leaf -of [get_nets -top -segments -of [get_pins -of [get_cells $gts] -filter {NAME =~ *TXUSRCLK2}]] -filter {direction == OUT}]} {
                     send_msg_id {PICXO-024} {INFO} "PICXO clock TXOUTCLK_I and GT TXUSRCLK2 have the same driver";
                } else {
                    send_msg_id {PICXO-024} {CRITICAL WARNING} "PICXO $picxo clock TXOUTCLK_I and GT $gts TXUSRCLK2 do not have the same driver, please check that these clocks are synchronous";
                };
            };
        } else {
        # DRC checks for FRACXO
            set gt_channels [get_cells -of [get_pins -leaf -of [get_nets -of [get_pins "$gts/QPLL0OUTCLK"]]] -filter {REF_NAME == GTYE3_CHANNEL || REF_NAME == GTHE4_CHANNEL  || REF_NAME == GTYE4_CHANNEL}];
            lappend gt_channels [get_cells -of [get_pins -leaf -of [get_nets -of [get_pins "$gts/QPLL1OUTCLK"]]] -filter {REF_NAME == GTYE3_CHANNEL || REF_NAME == GTHE4_CHANNEL || REF_NAME == GTYE4_CHANNEL}];
            set gt_channels [lsort -unique $gt_channels]
            foreach gt_channel $gt_channels {
                send_msg_id {FRACXO-026} {INFO} "Running DRC for FRACXO associated with\n$gts\n$gt_channels";
                send_msg_id {FRACXO-027} {WARNING} "Please check that the reference frequency is lower than the locked rate, the fPLL can only tune between N and N+1";
                set sdm0width [join "[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/SDM0WIDTH[1]]]] "Power"] \
                                     [string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/SDM0WIDTH[0]]]] "Power"]" ""];
                set sdm1width [join "[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/SDM1WIDTH[1]]]] "Power"] \
                                     [string equal -nocase [get_property TYPE [get_nets -of [get_pins $gts/SDM1WIDTH[0]]]] "Power"]" ""];
                set txpllclksel [join "[string equal -nocase [get_property TYPE [get_nets -of [get_pins $gt_channel/TXPLLCLKSEL[1]]]] "Power"] \
                                       [string equal -nocase [get_property TYPE [get_nets -of [get_pins $gt_channel/TXPLLCLKSEL[0]]]] "Power"]" ""];
                if { $txpllclksel == "11" } {
                    if { $sdm0width == "00" } { send_msg_id {PICXO-027} {INFO} "$gts port SDM0WIDTH is correctly connected to 2'b00";
                    } else                    { send_msg_id {PICXO-027} {CRITICAL WARNING} "$gts port SDM0WIDTH is not connected to 2'b00";
                    }
                    if { [string index [hex2bin [string index [get_property QPLL0_SDM_CFG0 $gts] 6]] 0] == "0"} {
                        send_msg_id {PICXO-025} {INFO} "$gts property QPLL0_SDM_CFG0 bit 7 is correctly set to 0";
                    } else {
                        send_msg_id {PICXO-025} {CRITICAL WARNING} "$gts property QPLL0_SDM_CFG0 bit 7 must be set to 1, it is currently set to 0, please check that the fractional QPLL is enabled in the GT wizard";
                    };
                } elseif {$txpllclksel == "10"} {
                    if { $sdm1width == "00" } { send_msg_id {PICXO-027} {INFO} "$gts port SDM1WIDTH is correctly connected to 2'b00";
                    } else                    { send_msg_id {PICXO-027} {CRITICAL WARNING} "$gts port SDM1WIDTH is not connected to 2'b00";
                    }
                    if { [string index [hex2bin [string index [get_property QPLL1_SDM_CFG0 $gts] 6]] 0] == "16'h0000"} {
                        send_msg_id {PICXO-025} {INFO} "$gts property QPLL1_SDM_CFG0 bit 7 is correctly set to 1";
                    } else {
                        send_msg_id {PICXO-025} {CRITICAL WARNING} "$gts property QPLL1_SDM_CFG0 bit 7 must be set to 1, it is currently set to 0, please check that the fractional QPLL is enabled in the GT wizard";
                    };
                } else {
                    send_msg_id {PICXO-025} {CRITICAL WARNING} "$gt_channel/TXPLLCLKSEL must be connected to "10" or "11"";
                };
            };
        };
};

proc main_picxo_pre_opt {{picxo_dbg_msg 0} {debug_timing 0}} {
    set start_time [clock seconds];
    send_msg_id {PICXO-100} {INFO} "Running PICXO pre_opt.tcl v2.6";
    set pre_opt_ver_num "26";
    set rvsig_incr 0;
    set no_gt_incr 0;
    set fracxo_incr 0;
    set picxos {};
    if {[info exists arch] == 0} {
            set arch [get_property architecture [get_property PART [current_project]]];
            if {$picxo_dbg_msg == 1} { puts "Arch is $arch, part is [get_property PART [current_project]]"; };
            if {[llength [get_sites -quiet -filter {SITE_TYPE == GTPE2_CHANNEL}]] != 0} {
                        if {[get_clock_region -of [get_sites GTPE2_CHANNEL_X0Y0]] == "X0Y0"} {set arch artix7_large;
                        } else { set arch artix7_small;
                        };
            } elseif {[llength [get_sites -quiet -filter {SITE_TYPE == GTHE2_CHANNEL}]] != 0} {set arch virtex7;
            } elseif {[llength [get_sites -quiet -filter {SITE_TYPE == GTXE2_CHANNEL}]] != 0} {set arch kintex7;
            } elseif {[llength [get_sites -quiet -filter {SITE_TYPE == GTHE3_CHANNEL || SITE_TYPE == GTYE3_CHANNEL || SITE_TYPE == GTHE4_CHANNEL || SITE_TYPE == GTYE4_CHANNEL}]] != 0} {set arch kintexu;
            };
    };
    if {$picxo_dbg_msg == 1} { puts "Arch is $arch";};
    #set picxos [lsort -dictionary [get_cells -hier -filter {LIB_CELL =~ *picxo_top || ORIG_REF_NAME =~ *picxo_top}]];
    #set picxos [lsort -dictionary [get_cells -quiet -hier -filter {ORIG_REF_NAME == picxo_top}]];
    set picxos [lsort -dictionary [get_cells -hier -filter {I_AM_PICXO == "true"}]];
    if {[llength $picxos] == 0} {
        send_msg_id {PICXO-015} {ERROR} "No Picxo instance found";
    } else {
        send_msg_id {PICXO-020} {INFO} "Found [llength $picxos] PICXOs:\n[join $picxos \n]";
    };

    foreach picxo $picxos {
        set picxo_dest {};
        set no_gt {};
        set gts {};
        set gt_sites {};
        set X_gt {};
        set Y_gt {};
        set X {};
        set Y {};
        set gt_type [get_property GT_TYPE [get_prop PARENT $picxo]];
        set mode    [get_property MODE    [get_prop PARENT $picxo]];
        set clk_reg [get_property CLOCK_REGION [get_prop PARENT $picxo]];
        set ver_num [get_property VER_NUM $picxo];
        set opt_done [get_property OPT_DONE $picxo];
        #if { $opt_done == "TRUE"  } {send_msg_id {PICXO-021} {INFO} "pre_opt.tcl has already been run for picxo $picxo";};
        if { $opt_done == "FALSE" } {            
            if {[bin2hex $ver_num] != $pre_opt_ver_num} {send_msg_id {PICXO-030} {CRITICAL WARNING} "pre_opt.tcl $pre_opt_ver_num version does not match picxo version [bin2hex $ver_num]"}
            send_msg_id {PICXO-021} {INFO} "$picxo version [bin2hex $ver_num] with GT type $gt_type";
            set txoutclk_i_pin [get_pins -of [get_cells $picxo] -filter {NAME =~ *TXOUTCLK_I || NAME =~ *txoutclk_i}];
            set refclk_i_pin [get_pins -of [get_cells $picxo] -filter {NAME =~ *REF_CLK_I || NAME =~ *ref_clk_i}];
            if {[get_clocks -quiet -of $refclk_i_pin] == ""}   {send_msg_id {PICXO-023} {CRITICAL WARNING} "$refclk_i_pin does not have a clock, please use create_clock to constraint this signal"};
            if {[get_clocks -quiet -of $txoutclk_i_pin] == ""} {
                     send_msg_id {PICXO-023} {CRITICAL WARNING} "$txoutclk_i_pin does not have a clock, please use create_clock to constraint this signal. The period will be set to 100 ns"
                     set txoutclk_i_per 100;
            } else { set txoutclk_i_per [get_property PERIOD [get_clocks -quiet -of $txoutclk_i_pin]];
            };
            
            switch $gt_type {
                GTP {set picxo_dest [get_cells -quiet -filter {PRIMITIVE_SUBGROUP == "gt" || PRIMITIVE_SUBGROUP == "GT"} -of [get_pins -quiet -leaf -filter {DIRECTION == in || DIRECTION == IN} -of [get_nets -quiet -of [get_pins -quiet "$picxo/dac_sign_o"]]]];}
                GTH { if {$mode == "PICXO"} {
                        set picxo_dest [get_cells -quiet -filter {PRIMITIVE_SUBGROUP == "gt" || PRIMITIVE_SUBGROUP == "GT"}\
                        -of [get_pins -quiet -leaf -filter {DIRECTION == in || DIRECTION == IN} -of [get_nets -quiet -of [get_pins -quiet "$picxo/dac_sign_o"]]]];
                      } elseif {$mode == "FRACXO"} {
                        set picxo_dest [get_cells -filter {PRIMITIVE_SUBGROUP == gt || PRIMITIVE_SUBGROUP == GT} -of\
                                       [get_nets -segments -of [get_pins -of [all_fanout -only_cells [get_pins -quiet "$picxo/volt_o[4]"]] -filter {DIRECTION == OUT || DIRECTION == out}]]];
                      }
                    }
                GTY { if {$mode == "PICXO"} {
                        set picxo_dest [get_cells -quiet -filter {PRIMITIVE_SUBGROUP == "gt" || PRIMITIVE_SUBGROUP == "GT"} -of\
                                       [get_pins -quiet -leaf -filter {DIRECTION == in || DIRECTION == IN} -of [get_nets -quiet -of [get_pins -quiet "$picxo/dac_sign_o"]]]];
                      } elseif {$mode == "FRACXO"} {
                        set picxo_dest [get_cells -filter {PRIMITIVE_SUBGROUP == gt || PRIMITIVE_SUBGROUP == GT} -of\
                                       [get_nets -segments -of [get_pins -of [all_fanout -only_cells [get_pins -quiet "$picxo/volt_o[4]"]] -filter {DIRECTION == OUT || DIRECTION == out}]]];
                      }
                    }
                GTX {set picxo_dest [filter [all_fanout -level 2 -only_cells -flat [get_pins -quiet "[get_prop PARENT $picxo]/DRPDATA_O"]]  {PRIMITIVE_SUBGROUP == gt || PRIMITIVE_SUBGROUP == GT}];}
                NO_GT {send_msg_id {PICXO-201} {INFO} "NCO mode, placing picxo in clock region $clk_reg"; set picxo_dest {}; set no_gt 1; set gts "no_gt_detected";}
                default {send_msg_id {PICXO-202} {ERROR} "$gt_type is not supported"; set picxo_dest {};}
            }

            if {[llength $picxo_dest] == 0 && $gt_type != "NO_GT"} {send_msg_id {PICXO-202} {ERROR} "$picxo set to $gt_type but no GT detected, please check that GT is LOC'ed and that ACC_DATA_O (GTP, GTY, GTH) or DRP_DATA_O(GTX) is connected to the GT";
            } elseif {$gt_type != "NO_GT" && [llength $picxo_dest] != 0} {
                                            send_msg_id {PICXO-022} {INFO} "Found $picxo drives $picxo_dest"; set gts $picxo_dest; set no_gt 0;
                                            foreach gt_picxo $picxo_dest {picxo_drc $gt_picxo $picxo $mode;}
                                            set picxo_dest [lindex $picxo_dest end]; 
                                            set gts $picxo_dest;
                                            set gt_sites [get_sites -quiet -of $gts];
                                            if {$gt_sites == ""} { send_msg_id {PICXO-204} {ERROR} "$gts is not LOC'ed";
                                            } else {
                                                send_msg_id {PICXO-203} {INFO} "$picxo will be relatively placed to $picxo_dest";
                                            };    
            };
            
            if {$picxo_dbg_msg == 1} {puts "Arch is $arch";puts "Found Picxo Pin TXOUTCLK_I $txoutclk_i_pin";puts "Found Picxo Pin REF_CLK_I $refclk_i_pin";puts "Found Picxo GT instance $gts";puts "Found GT site $gt_sites";};
            if {$picxo_dbg_msg == 1} {puts "GT LOC is $gt_sites";};
            #### 1_2  INPUT CLK of UP flop
            #### 2_3   UP
            #### 20_30 DOWN
            #### 5_40  UP_d
            #### 50_4  DN_d

            set 20 [get_cells -filter "PARENT =~ $picxo*" -of [get_pins -leaf -filter "DIRECTION == IN && NAME =~ *C" -of [get_nets -of [get_pins -leaf -of [get_cells -of [get_pins -leaf -of [get_nets -of $txoutclk_i_pin -boundary_type lower] -filter "DIRECTION == IN && NAME =~ *C"]] -filter "DIRECTION == OUT"]]]]
            set 30_20 [get_nets -of [get_pins -leaf -of $20 -filter {NAME =~ *CLR}]];
            set 20_30 [get_nets -of [get_pins -leaf -of $20 -filter {NAME =~ *Q}]] ;
            set 30 [get_cells -of [get_pins -leaf -of $30_20 -filter {DIRECTION == OUT}]];
            set 10_20 [get_nets -of [get_pins -leaf -of $20 -filter {NAME =~ *C}]];
            set 10 [get_cells -of [get_pins -leaf -of $10_20 -filter {DIRECTION == OUT}]] ;
            set 50 [get_cells -of [get_nets -of [get_pins -of $20 -filter {NAME =~ *Q}]] -filter {REF_NAME == LUT1}];
            set dith_mux [get_cells -of [get_pins -leaf -of [get_nets -of [get_pins -hier -filter "NAME =~ $picxo/*C"]] -filter {DIRECTION == OUT}] -filter "REF_NAME == LUT6 && PARENT =~ $picxo*"];
            set 2 [get_cells -of [get_pins -of [get_nets -of [get_pins -of $dith_mux -filter {DIRECTION == OUT}]] -filter {DIRECTION == IN}]];
            set_property DONT_TOUCH true $dith_mux;
            set 3_2 [get_nets -of [get_pins -leaf -of $2 -filter {NAME =~ *CLR}]];
            set 2_3 [get_nets -of [get_pins -leaf -of $2 -filter {NAME =~ *Q}]]  ;
            set 3 [get_cells -of [get_pins -leaf -of $3_2 -filter {DIRECTION == OUT}]];
            set 1_2 [get_nets -of [get_pins -leaf -of $2 -filter {NAME =~ *C}]];
            set 1 [get_cells -of [get_pins -leaf -of [get_nets -of [get_pins -of $dith_mux -filter {NAME =~ *I0}]] -filter {DIRECTION == OUT}]];
            set 1_dith_mux [get_nets -of [get_pins -of $dith_mux -filter {NAME =~ *I0}]];
            set 5 [get_cells -of [get_nets -of [get_pins -of $2 -filter {NAME =~ *Q}]] -filter {REF_NAME == LUT1}];
            set 50_4 [get_nets -of [get_pins -leaf -of $50 -filter {DIRECTION == OUT}]];
            set 5_40 [get_nets -of [get_pins -leaf -of $5 -filter {DIRECTION == OUT}]];
            set 4 [get_cells -of [get_pins -leaf -of $50_4 -filter {DIRECTION == IN}]];
            set 40 [get_cells -of [get_pins -leaf -of $5_40 -filter {DIRECTION == IN}]];
            set 6 [get_pins -leaf -of [get_nets -of [get_pins -leaf -of $4 -filter {DIRECTION == OUT}]] -filter {DIRECTION == IN}];
            set 60 [get_pins -leaf -of [get_nets -of [get_pins -leaf -of $40 -filter {DIRECTION == OUT}]] -filter {DIRECTION == IN}];
            set 40_60 [get_nets -of [get_pins -leaf -of $40 -filter {DIRECTION == OUT}]];
            set 4_6 [get_nets -of [get_pins -leaf -of $4 -filter {DIRECTION == OUT}]];
            if {$picxo_dbg_msg == 1} {puts "1 is $1"; puts "2 is $2"; puts "dith_mux is $dith_mux"; puts "3 is $3"; puts "4 is $4"; puts "5 is $5"; puts "10 is $10"; puts "20 is $20"; puts "30 is $30"; puts "40 is $40"; puts "50 is $50";};
            set rpm_element [get_rpm_elements $4];
            set list_netd [lindex $rpm_element 0];
            set LUT_listd [lindex $rpm_element 1];
            set FF_listd  [lindex $rpm_element 2];
            set catcher_d [get_cells -of [get_pins -of [lindex $list_netd end] -filter {IS_CLOCK}]]
            set rpm_element [get_rpm_elements $40];
            set list_netu [lindex $rpm_element 0];
            set LUT_listu [lindex $rpm_element 1];
            set FF_listu [lindex $rpm_element 2];
            set catcher_u [get_cells -of [get_pins -of [lindex $list_netu end] -filter {IS_CLOCK}]]
            
            if {$picxo_dbg_msg == 1} {
                puts "Found nets U $list_netu" ;
                puts "Found LUT U $LUT_listu"  ;
                puts "Found FF U $FF_listu"    ;
                puts "Found nets D $list_netd" ;
                puts "Found LUT D $LUT_listd"  ;
                puts "Found FF D $FF_listd"    ;
                puts "Found FF catcher D $catcher_d"    ;
                puts "Found FF catcher U $catcher_u"    ;
            };
        
            #    $1 rsig_reg
            #    $dith_mux
            #    $2 up_reg
            #    $3 pd_reset_up_i
            #    $4 up_dn_slow1
            #    $5 LUT_up
            
            set macrodu {};
            create_generated_clock -name vsig$rvsig_incr -source [get_pins $10/C] -divide_by 2 [get_pins $10/Q] ;
            create_generated_clock -name rsig$rvsig_incr -source [get_pins $1/C]  -divide_by 2 [get_pins $1/Q]  ;
            create_clock -name d$rvsig_incr -period 10 [get_pins $catcher_d/C];
            create_clock -name u$rvsig_incr -period 10 [get_pins $catcher_u/C];
            set_max_delay -datapath_only -from [get_pins $catcher_d/C] $txoutclk_i_per;
            set_max_delay -datapath_only -from [get_pins -filter {IS_CLOCK == 1} -of [get_cells -of [get_pins -filter {DIRECTION == OUT} -of [get_nets -of [get_pins $catcher_d/CLR]]]]] -to [get_pins $catcher_d/CLR] $txoutclk_i_per;
            set_max_delay -datapath_only -from [get_pins $catcher_u/C] $txoutclk_i_per;
            set_max_delay -datapath_only -from [get_pins -filter {IS_CLOCK == 1} -of [get_cells -of [get_pins -filter {DIRECTION == OUT} -of [get_nets -of [get_pins $catcher_u/CLR]]]]] -to [get_pins $catcher_u/CLR] $txoutclk_i_per;
            send_msg_id {PICXO-205} {INFO} "Timing Constraints created";
            if {$arch == "kintexu"} {
                if {$gt_type == "GTY"} {send_msg_id {PICXO-30} {WARNING} "PICXO is Pre-Production for GTY";};
                set lut_per_slice 8;
                set height 5;
                set LUT_BELs {A6LUT B6LUT C6LUT D6LUT E6LUT F6LUT G6LUT H6LUT};
                set FF_BELs {AFF BFF CFF DFF EFF FFF GFF HFF};
                lappend macrodu $1 X0Y0 $dith_mux X1Y0 $2 X2Y0 $3 X3Y0 $4 X5Y0 $5 X3Y0 ;
                lappend macrodu $10 X0Y0 $20 X2Y0 $30 X3Y0 $40 X4Y0 $50 X4Y0;
                for {set i 0} {$i < [llength $LUT_listd]} {incr i} {
                    lappend macrodu [get_cells [lindex $LUT_listd $i]] X4Y[expr (1+($i/$lut_per_slice))];
                    lappend macrodu [get_cells [lindex $FF_listd $i]] X4Y[expr (1+($i/$lut_per_slice))];
                };
                lappend macrodu [get_cells $catcher_d] X5Y[expr (1+([llength $LUT_listd]-1)/$lut_per_slice)]
                for {set i 0} {$i < [llength $LUT_listu]} {incr i} {
                    lappend macrodu [get_cells [lindex $LUT_listu $i]] X2Y[expr (1+($i/$lut_per_slice))];
                    lappend macrodu [get_cells [lindex $FF_listu $i]] X2Y[expr (1+($i/$lut_per_slice))];
                };
                lappend macrodu [get_cells $catcher_u] X3Y[expr (1+([llength $LUT_listu]-1)/$lut_per_slice)]
            } else {
                set lut_per_slice 4;
                set height 11;
                set LUT_BELs {A6LUT B6LUT C6LUT D6LUT};
                set FF_BELs {AFF BFF CFF DFF};
                lappend macrodu $1 X2Y0 $dith_mux X1Y1 $2 X2Y2 $3 X2Y2 $4 X4Y2 $5 X4Y2 ;
                lappend macrodu $10 X2Y3 $20 X2Y4 $30 X2Y4 $40 X0Y2 $50 X0Y2;
                for {set i 0} {$i < [llength $LUT_listd]} {incr i} {
                    lappend macrodu [get_cells [lindex $LUT_listd $i]] X4Y[expr (3+($i/$lut_per_slice))];
                    lappend macrodu [get_cells [lindex $FF_listd $i]] X4Y[expr (3+($i/$lut_per_slice))];
                };
                lappend macrodu [get_cells $catcher_d] X5Y[expr (3+([llength $LUT_listd]-1)/$lut_per_slice)]
                for {set i 0} {$i < [llength $LUT_listu]} {incr i} {
                    lappend macrodu [get_cells [lindex $LUT_listu $i]] X0Y[expr (3+($i/$lut_per_slice))];
                    lappend macrodu [get_cells [lindex $FF_listu $i]] X0Y[expr (3+($i/$lut_per_slice))];
                };
                lappend macrodu [get_cells $catcher_u] X1Y[expr (3+([llength $LUT_listu]-1)/$lut_per_slice)]
            };
            
            if {[get_macros -quiet du$rvsig_incr] == {}} {
                create_macro du$rvsig_incr;
                update_macro du$rvsig_incr $macrodu;
            };
            if {$arch == "kintexu"} {
                set_property BEL AFF $catcher_u ;
                set_property BEL AFF $catcher_d ;
                set_property BEL AFF $1     ;
                set_property BEL EFF $10    ;
                set_property BEL AFF $2     ;
                set_property BEL EFF $20    ;
                set_property BEL D6LUT $3   ;
                set_property BEL F6LUT $30  ;
                set_property BEL A6LUT $4   ;
                set_property BEL A6LUT $40  ;
                set_property BEL A6LUT $5   ;
                set_property BEL E6LUT $50  ;
            } else {
                set_property BEL AFF $catcher_u ;
                set_property BEL AFF $catcher_d ;
                set_property BEL AFF $1     ;
                set_property BEL AFF $10    ;
                set_property BEL AFF $2     ;
                set_property BEL AFF $20    ;
                set_property BEL A6LUT $3   ;
                set_property BEL A6LUT $30  ;
                set_property BEL A6LUT $4   ;
                set_property BEL A6LUT $40  ;
                set_property BEL B6LUT $5   ;
                set_property BEL B6LUT $50  ;
            };
            
            if {[get_property LOCK_PINS $3] == ""}  {
                set_property LOCK_PINS {I0:A6 I1:A5} $3   ;
                set_property LOCK_PINS {I1:A6 I0:A5} $30  ;
                set_property LOCK_PINS {I0:A5 I1:A6} $4   ;
                set_property LOCK_PINS {I0:A5 I1:A6} $40  ;
                set_property LOCK_PINS {I0:A6} $5         ;
                set_property LOCK_PINS {I0:A6} $50        ;
            };
            if {[get_property LOCK_PINS $dith_mux] == ""}  {
                set_property LOCK_PINS {I0:A6 I1:A5 I2:A4 I3:A3 I4:A2 I5:A1} $dith_mux;
            };
            
            for {set i 0} {$i < [llength $LUT_listd]} {incr i} {
                set_property BEL [lindex $LUT_BELs [expr ($i%$lut_per_slice)]] [get_cells [lindex $LUT_listd $i]];
                set_property BEL [lindex $FF_BELs [expr ($i%$lut_per_slice)]] [get_cells [lindex $FF_listd $i]];
                set_property IS_BEL_FIXED 1 [get_cells [lindex $FF_listd $i]];
                set_property IS_BEL_FIXED 1 [get_cells [lindex $LUT_listd $i]];
                if {[get_property LOCK_PINS [get_cells [lindex $LUT_listd $i]]] == ""}  {set_property LOCK_PINS {I0:A6} [get_cells [lindex $LUT_listd $i]]};
            };

            for {set i 0} {$i < [llength $LUT_listu]} {incr i} {
                set_property BEL [lindex $LUT_BELs [expr ($i%$lut_per_slice)]] [get_cells [lindex $LUT_listu $i]];
                set_property BEL [lindex $FF_BELs [expr ($i%$lut_per_slice)]] [get_cells [lindex $FF_listu $i]];
                set_property IS_BEL_FIXED 1 [get_cells [lindex $FF_listu $i]];
                set_property IS_BEL_FIXED 1 [get_cells [lindex $LUT_listu $i]];
                if {[get_property LOCK_PINS [get_cells [lindex $LUT_listu $i]]] == ""}  {set_property LOCK_PINS {I0:A6} [get_cells [lindex $LUT_listu $i]]};
            };
            
            if {$gt_type != "NO_GT"} {
                regexp {X(\d+)Y(\d+)} $gt_sites test X_gt Y_gt;
                if {$picxo_dbg_msg == 1} {puts "X_gt $X_gt Y_gt $Y_gt";};
                if {$gt_sites != ""} {
                    #set top_left  [get_sites -quiet -of [get_tiles [get_property -quiet TOP_LEFT_TILE [get_clock_region -quiet [get_property -quiet CLOCK_REGION $gt_sites]]]]];
                    set top_right [lindex [lsort -dictionary [get_sites -quiet -of [get_clock_region -quiet [get_property -quiet CLOCK_REGION $gt_sites]] -filter {NAME =~ SLICE_*}]] end];
                    set bot_left  [lindex [lsort -dictionary [get_sites -quiet -of [get_clock_region -quiet [get_property -quiet CLOCK_REGION $gt_sites]] -filter {NAME =~ SLICE_*}]] 0];
                    
                    regexp {X(\d+)} $top_right test X;
                    regexp {Y(\d+)} $bot_left  test Y;
                    if {$arch != "artix7_large"} {
                        if {[get_property RPM_X $gt_sites] > [get_property RPM_X $top_right]} {set right 1;} else {set right -1; regexp {X(\d+)} $bot_left test X;};
                        if {$arch == "kintexu" && $mode == "PICXO"} {
                            if {$right == 1} {set offset_x 5;} else {set offset_x 1;};
                            if {[expr ($Y_gt % 4)] < 2} {set offset_y 0} else {set offset_y 4};
                        } elseif {$mode == "FRACXO"} {
                            if {$right == 1} {set offset_x 5;} else {set offset_x 0;};
                            set offset_y 0;
                        } else {
                            set offset_x 4;
                            if {[expr ($Y_gt % 4)] < 2} {set offset_y 3} else {set offset_y 9};
                        };
                    } else {
                        regexp {X(\d+)} [get_property CLOCK_REGION $gt_sites] test left
                        if {$left == 0} {set right 1; set offset_x 35;} else {set right 1; set offset_x 44;};
                        if {[expr ($Y_gt % 4)] < 2} {set offset_y 3} else {set offset_y 9};
                    };
                    
                    if {$picxo_dbg_msg == 1} {puts "X $X Y $Y right $right offset_x $offset_x offset_y $offset_y"};
                    if {$mode == "PICXO"} { set Y [expr (($Y+ $offset_y)+($Y_gt % 4)*$height)];
                                            set X [expr ($X-($offset_x * $right))]; 
                    } else { set Y [expr ($Y+ 10)]
                             set X [expr ($X-($offset_x * $right)) ]; 
                    };
                    if {[get_property IS_USED [get_sites SLICE_X$X\Y$Y]]==0 || $mode == "PICXO"} { set_property LOC SLICE_X$X\Y$Y $10;} else {set X [expr ($X+(6 * $right))]; set_property LOC SLICE_X$X\Y$Y $10; };
                    if {$picxo_dbg_msg == 1} {puts "X $X Y $Y"};
                }
            } else {
            ## NO GT MODE
                switch $arch { 
                    kintexu {
                        set right -1;
                        set offset_x 12;
                        set offset_y 0;
                        set X_gt 0;
                        set Y_gt 0;}
                    kintex7 {
                        regexp {X(\d+)} [get_clock_region $clk_reg] test left
                        if {$left == 0} {set offset_x 43;} else {set offset_x 12;};
                        set right -1;
                        set offset_y 3;
                        set X_gt 0;
                        set Y_gt 0;}
                    virtex7 {
                        regexp {X(\d+)} [get_clock_region $clk_reg] test left
                        if {$left == 0} {set offset_x 21;} else {set offset_x 16;};
                        set right -1;
                        set offset_y 3;
                        set X_gt 0;
                        set Y_gt 0;}
                    artix7_large {
                        regexp {X(\d+)} [get_clock_region $clk_reg] test left
                        if {$left == 0} {set offset_x 15;} else {set offset_x 33;};
                        set right -1;
                        set offset_y 3;
                        set X_gt 0;
                        set Y_gt 0;}
                    artix7_small {
                        regexp {X(\d+)} [get_clock_region $clk_reg] test left
                        if {$left == 0} {set offset_x 31;} else {set offset_x 3;};
                        set right -1;
                        set offset_y 3;
                        set X_gt 0;
                        set Y_gt 0;}
                    default {
                        regexp {X(\d+)} [get_clock_region $clk_reg] test left
                        if {$left == 0} {set offset_x 27;} else {set offset_x 8;};
                        set right -1;
                        set offset_y 3;
                        set X_gt 0;
                        set Y_gt 0;}
                };
                #set top_left  [get_sites -of [get_tiles [get_property TOP_LEFT_TILE [get_clock_region $clk_reg]]]];
                #set top_right [lindex [lsort -dictionary [get_sites -of [get_clock_region $clk_reg] -filter {NAME =~ SLICE_*}]] end];
                if {[llength [get_sites -of [get_clock_region $clk_reg] -filter {NAME =~ SLICE_*}]] == 0} {
                        send_msg_id {PICXO-026} {ERROR} "Parameter CLOCK_REGION of $picxo is set to $clk_reg which does not contains slices";
                        send_msg_id {PICXO-026} {ERROR} "$picxo will not be placed correctly";
                } else {
                    set bot_left  [lindex [lsort -dictionary [get_sites -of [get_clock_region $clk_reg] -filter {NAME =~ SLICE_*}]] 0];
                    regexp {X(\d+)Y(\d+)} $bot_left  test X Y;
                    if {$picxo_dbg_msg == 1} {puts "X $X Y $Y right $right offset_x $offset_x offset_y $offset_y"};
                    set Y [expr ($Y+ $offset_y)];
                    set X [expr ($X-($offset_x * $right))]; 
                    if {[get_property IS_USED [get_sites SLICE_X$X\Y$Y]]==0} { set_property LOC SLICE_X$X\Y$Y $10;} else {incr no_gt_incr;set Y [expr ($Y+ $no_gt_incr * $height)];set_property LOC SLICE_X$X\Y$Y $10;};
                    if {$picxo_dbg_msg == 1} {puts "X $X Y $Y"};
                };
            };
            if {$debug_timing == 0} {
                    set_disable_timing $20;
                    set_disable_timing $2;
                    set_disable_timing $40;
                    set_disable_timing $4;
                    set_disable_timing $3;
                    set_disable_timing $30;
                    set_disable_timing $50;
                    set_disable_timing $5;
                    set_false_path -to [get_pins $2/CLR];
                    set_false_path -to [get_pins $20/CLR];
            };
            set_property OPT_DONE "TRUE" $picxo
            incr rvsig_incr;
            send_msg_id {PICXO-110} {INFO} "Completed placement constraints for picxo $picxo";
        };
    };
    set stop_time [clock seconds]
    send_msg_id {PICXO-101} {INFO} "Completed pre_opt.tcl in [expr $stop_time - $start_time ] seconds";
};

if {[info exists picxo_dbg_msg] == 0} {set picxo_dbg_msg 0};
if {[info exists debug_timing] == 0} {set debug_timing 0};
main_picxo_pre_opt $picxo_dbg_msg $debug_timing;












